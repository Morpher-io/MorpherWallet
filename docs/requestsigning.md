<!--
Created: Thu Dec 10 2020 12:54:14 GMT+0100 (Central European Standard Time)
Modified: Thu Dec 10 2020 14:05:02 GMT+0100 (Central European Standard Time)
-->

# Request Signing

To authenticate a stateless request to the backend to update user information, the requests are signed.

The signature method is very similar to HMAC signatures used by Amazon.

In general it prevents:

1. MIDM Attacks by signing the payload
2. Replay Attacks by introducing a nonce

## Nonce

The nonce is a known number that increases every time an authenticated request is sent to the backend. No nonce is ever the same. The nonce is part of the payload.

## Payload

When the payload for POST or GET requests is sent, then an additional header is added to the request with the signature.

## Signature

The signature is generated by using the private key of the user. The eth-address for the user is stored backend-side in the database. In general, every authenticated request must fulfill the following equation:

 `eth_address_stored_in_backend == ec_recover(request.headers.signature, request.body.payload);`

Otherwise it will fail.

To recover the eth_address we use https://web3js.readthedocs.io/en/v1.2.0/web3-eth-personal.html#ecrecover

## Client Side Signature Creation

The signature is created client-side with the keystore (web3.eth.accounts.wallet.sign).
In general it follows this flow:

:[RequestSignatureCreationFlow](fig_requestsignature.plantuml)

The following pseudo-code is responsible for the signature creation:

``` javascript
function addSignature(requestObject) {
    requestObject.body.nonce = getNonceFromBackend();

    /**
    requestObject.body e.g.: 
    {
        email: "thomas@morpher.some",
        payload: {
            email2fa: true,
            authenticator2fa: false
        },
        nonce: 12345
    }
    */
    data_sorted = sortAlphabeticallyByKey(requestObject.body)
    //watch out that also sub-objects are sorted! So it looks like this:
    data_sorted = {
        email: ...,
        nonce: ...,
        payload: {
            authenticator2fa: ...,
            email2fa: ...
        }
    }

    //then stringify it - either like this:
    signedMessage = keystore.sign(JSON.stringify(data_sorted))

    requestObject.headers.signedMessage = signedMessage;
    requestObject.headers.signatureKey = sha256(email);
    return requestObject
}

//here the function calls the backend and adds the signature
fetch('/backendUrl', addSignature(requestObject));
```

## Backend

On the backend a middleware is checking the request body against the users eth_address after ec_recovery of the signature:

In Pseudocode:

``` javascript
recovery = findOne({
        where: {
            "key": req.headers.signatureKey
        }
    }, include: User)
if (recovery) {
    eth_address = ecrecover(JSON.stringify(sortAlphabetically(req.body)), req.headers.signedMessage)
    if (eth_address == recovery.user.eth_address) {
        //SUCCESS HERE
        //routing continues
    }

}

throw 505-error //happens in any other case.
```
